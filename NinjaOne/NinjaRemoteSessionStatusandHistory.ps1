<#
.SYNOPSIS
    This script is used to obtain the current Ninja Remote session status and history.

.DESCRIPTION
    Script looks for more than 1 NCStreamer process to be active and if so, looks at the logs generated by Ninja Remote to determine session start and session end.
    Custom fields are filled out to indicate start and end session times, as well as a checkbox to indicate active session. Additional custom field to record session history.

    # ---------------------------------------------------------------
    # Author: Mark Giordano
    # Date: 12/14/2024
    # Description: Gets Ninja Remote Session status to custom fields.
    # Updated: 1/17/2025 - Added Session History Collection
    # Updated: 4/18/2025 - Removed reliance on Agent Log. Added Tag option.
    # Updated: 6/2/2025 - Reworked script logic. Added Session Type Column.
    # ---------------------------------------------------------------

.NOTES
    REQUIRED: Custom Fields
    Name: NinjaRemoteSessionStart
    Type: Text
    Name: NinjaRemoteSessionEnd
    Type: Text
    Name: NinjaRemoteSessionActive
    Type: Checkbox
    Name: NinjaRemoteSessionHistory
    Type: WYSIWYG

    OPTIONAL: Tags
    Make sure you've created a tag with your desired name.
    At the start of the script, after the fuctions, is $SetTag = $env:setTag. If you add a script variable in Ninja called setTag, this will
    set the device with the tag name you entered. It will remove it upon session end.

    The Session Start/End and Session Active can be added to the Device Grid to keep an eye on currently active sessions. 

    Designed to be ran as a Script Result Condition, the more frequent, the greater accuracy the script will have for active sessions. Recommended 1-5 minute intervals. 
    Exits 0, even if issues are found where it cannot collect the necessary info, this is to prevent alerts. This will simply run at the alloted frequency and keep the 
    custom fields updated.

    By default saves the most recent 30 session events. This can be adjusted by changing $SessionsToKeep.
#>

#### Functions ####
function ConvertTo-HTMLTable {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [array]$Objects,
        [string]$NinjaInstance,
        [array]$ExcludedProperties = @('RowColor'),
        [string]$IncludeHeading
    )
    $BuildHTML = [System.Text.StringBuilder]::New()
    if ($IncludeHeading) {
        [void]$BuildHTML.Append("<h1 style='text-align: left'>$IncludeHeading</h1>")
    }
    
    [void]$BuildHTML.Append('<table>')
    [void]$BuildHTML.Append('<thead><tr>')

    $Objects[0].PSObject.Properties.Name | Where-Object { $_ -notin $ExcludedProperties } | 
    ForEach-Object { [void]$BuildHTML.Append("<th>$_</th>") }
    [void]$BuildHTML.Append('</tr></thead><tbody>')

    foreach ($Object in $Objects) {
        if ($Object.RowColor) { 
            [void]$BuildHTML.Append("<tr class='$($Object.RowColor)'>")
        }
        else {
            [void]$BuildHTML.Append("<tr>")
        }
        
        $FilteredProperties = $Object.PSObject.Properties.Name | Where-Object { $_ -notin $ExcludedProperties }
        foreach ($Property in $FilteredProperties) {
            $Value = $Object.$Property
            if ($Property -eq 'systemName') {
                $url = "https://$NinjaInstance/#/deviceDashboard/$($Object.Id)/overview"
                [void]$BuildHTML.Append("<td><a href='$url' target='_blank'>$Value</a></td>")
            }
            else {
                [void]$BuildHTML.Append("<td>$Value</td>")
            }
        }
        [void]$BuildHTML.Append('</tr>')
    }
    [void]$BuildHTML.Append('</tbody></table>')
    $FinalHTML = $BuildHTML.ToString()
    return $FinalHTML
}

function Update-NRSessionHistory {
    param (
        [Parameter(Mandatory = $true)]
        [PSCustomObject[]]$UpdateAllSessions
    )

    $CheckHTML = Ninja-Property-Get NinjaRemoteSessionHistory
    Start-Sleep 5
    if (($CheckHTML | ConvertFrom-Json).html) {
        [xml]$HTMLtoXML = ($CheckHTML | ConvertFrom-Json).html
        $THeaders = $HTMLtoXML.SelectNodes("//thead/tr/th") | ForEach-Object { $_.InnerText }
        $TRows = $HTMLtoXML.SelectNodes("//tbody/tr")
        $HTMLtoObject = [System.Collections.Generic.List[object]]::New()
        foreach ($Row in $TRows) {
            $Value = $Row.td
            if ([string]::IsNullOrWhiteSpace($Value)) { 
                continue 
            }
            $RowObject = [PSCustomObject]@{}
            for ($i = 0; $i -lt $THeaders.Count; $i++) {
                $RowObject | Add-Member -MemberType NoteProperty -Name $THeaders[$i] -Value $Value[$i]
            }
            $HTMLtoObject.Add($RowObject)
        }

        ## This takes the previous versions data without the session type column and adjusts for it
        if (($HTMLtoObject[0] | Get-Member -MemberType NoteProperty).Count -eq 3) {
            $TempObject = [System.Collections.Generic.List[object]]::New()
            foreach ($Record in $HTMLtoObject) {
                $TempRecord = [PSCustomObject]@{
                    'Session Start'    = $Record.'Session Start'
                    'Session End'      = $Record.'Session End'
                    'Session Type'     = ''
                    'Session Duration' = $Record.'Session Duration'
                }
                
                $TempObject.Add($TempRecord)
            }
            $HTMLtoObject = $TempObject
        }

        foreach ($NewSession in $UpdateAllSessions) {
            $HTMLtoObject.Add($NewSession)
        } 

        $HTMLtoObject = $HTMLtoObject | Sort-Object 'Session Start' -Descending

        if ($HTMLtoObject.Count -gt $SessionsToKeep) {
            $HTMLtoObject = $HTMLToObject[0..($SessionsToKeep - 1)]
        }

        ## WYSIWYG fields have a limit of 200k characters. This will remove the oldest entry
        ## if character length is 190k or more, ensuring enough space for the most recent entry.
        if ($CheckHTML.Length -ge 190000) {
            Write-Host 'Removing oldest entry due to character limit...'
            $HTMLtoObject = $HTMLToObject[0..($HTMLToObject.Count - 2)]
        }

        $HTML = ConvertTo-HTMLTable $HTMLtoObject
        $HTML | Ninja-Property-Set-Piped NinjaRemoteSessionHistory
    }
    else {
        $HTML = ConvertTo-HTMLTable $UpdateAllSessions
        $HTML | Ninja-Property-Set-Piped NinjaRemoteSessionHistory
    }
}

function Clear-NRSessionCustomFields {

    Ninja-Property-Set NinjaRemoteSessionActive 0
    Ninja-Property-Set NinjaRemoteSessionStart ''
    Ninja-Property-Set NinjaRemoteSessionEnd ''

    if (!([string]::IsNullOrWhiteSpace($SetTag))) {
        Write-Host 'Removing NinjaTag'
        Remove-NinjaTag "$SetTag"
    }

}

#### End Functions ####

$SessionsToKeep = 30
$NRLogsLocation = "$env:systemroot\temp"
$SetTag = $env:setTag

$NRPIDFiles = Get-ChildItem $NRLogsLocation | Where-Object { $_.Name -match 'NRPID_' } | Sort-Object LastWriteTime
$CheckifStartTimeExists = Ninja-Property-Get NinjaRemoteSessionStart
Start-Sleep 3
$CheckifEndTimeExists = Ninja-Property-Get NinjaRemoteSessionEnd
Start-Sleep 3

$NRProcess = Get-CimInstance Win32_Process | Where-Object { $_.Name -eq "ncstreamer.exe" } | 
Select-Object Name, ProcessID, SessionId, @{Name = "StartTime"; Expression = { ($_.CreationDate -as [datetime]).ToLocalTime() } } | 
Sort-Object StartTime


if (($NRProcess | Measure-Object).Count -gt 1) {
    $NRDetails = $NRProcess[($NRProcess | Measure-Object).Count - (($NRProcess | Measure-Object).Count - 1) ] 
    $NRStartTime = $NRDetails.StartTime
    if (!($NRStartTime)) {
        $NRStartTime = (Get-ChildItem "$($NRLogsLocation)" | 
            Where-Object { $_.Name -match "ncstreamer$($NRDetails.ProcessID)" }).CreationTime
    }

    ## Skip first one here since that is the always the default parent instance
    foreach ($NRP in ($NRProcess | Select-Object -Skip 1)) {
        try {
            if (!(Test-Path "$NRLogsLocation\NRPID_$($NRP.ProcessID)")) {
                New-Item "$NRLogsLocation\NRPID_$($NRP.ProcessID)" -Force -ErrorAction Stop
            }
        }
        catch {
            Write-Host 'Unable to record the NR Remote Process ID for use in collecting the session end time. Exiting.'
            Write-Host "$($_.Exception.Message)"
            exit 0
        }
    }

    if ([String]::IsNullOrWhiteSpace($CheckifStartTimeExists) -or (!([datetime]$CheckifStartTimeExists -match [datetime]$NRStartTime))) {
   
        Ninja-Property-Set NinjaRemoteSessionStart ($NRStartTime.ToString("yyyy-MM-dd HH:mm:ss"))
        Ninja-Property-Set NinjaRemoteSessionActive 1
        Ninja-Property-Set NinjaRemoteSessionEnd ''
    
        if (!([string]::IsNullOrWhiteSpace($SetTag))) {
            Write-Host 'Setting NinjaTag'
            Set-NinjaTag "$SetTag"
        }
    }
    exit 0
}

if (!([string]::IsNullOrWhiteSpace($CheckifEndTimeExists)) -or ([string]::IsNullOrWhiteSpace($CheckifStartTimeExists))) {
    Write-Host 'End time already exists or there was no previously recorded start time. Exiting.'
    exit 0
}

$AllNRLogs = Get-ChildItem $NRLogsLocation | Where-Object { ($_.Name -match 'ncstreamer') -and ($_.Name -notmatch 'ncstreamer_') } | 
Sort-Object LastWriteTime

$AllSessions = foreach ($NRPID in $NRPIDFiles) {
    try {
        $NRPIDConfirmation = ($NRPID).Name.Substring(6)
    }
    catch {
        Write-Host "File: $($NRPID.Name) isn't in the expected format. Skipping..."
        Write-Host "$($_.Exception.Message)"
        continue
    }

    $MatchingNRPIDLog = $AllNRLogs | Where-Object { $_.Name -match $NRPIDConfirmation }

    if (!($MatchingNRPIDLog)) {
        Write-Host "Unable to match NRPID $NRPIDConfirmation with a log file. Skipping..."
        continue
    }

    $Content = (Get-Content $MatchingNRPIDLog.FullName | Where-Object { $_ -match 'ProcessSessionId:' }).ToString()
    $SessionID = [regex]::Match($Content, 'ProcessSessionId:\s*\d+').Value
    
    if ($SessionID -match '0') {
        $SessionType = 'Background Mode'  
    }
    else {
        $SessionType = 'Normal Mode'
    } 

    $NRSessionEndTime = $($MatchingNRPIDLog.LastWriteTime).ToString("yyyy-MM-dd HH:mm:ss")
    $SessionDuration = $MatchingNRPIDLog.LastWriteTime - $MatchingNRPIDLog.CreationTime

    [PSCustomObject]@{
        'Session Start'    = $MatchingNRPIDLog.CreationTime.ToString("yyyy-MM-dd HH:mm:ss")
        'Session End'      = $NRSessionEndTime
        'Session Type'     = $SessionType
        'Session Duration' = '{0:D2} Days | {1:D2} Hours | {2:D2} Minutes | {3:D2} Seconds' -f $SessionDuration.Days, $SessionDuration.Hours, $SessionDuration.Minutes, $SessionDuration.Seconds
    }
}

if (!($AllSessions)) {
    Write-Host 'No active sessions and no previous sessions found to update.'
    Write-Host 'Resetting NR Session Active, StartTime, EndTime and Tag if applicable.'
    Clear-NRSessionCustomFields
    exit 0
}

Update-NRSessionHistory -UpdateAllSessions $AllSessions

$LastNRPID = $NRPIDFiles | Select-Object -Last 1

try {
    $NRPIDConfirmation = ($LastNRPID).Name.Substring(6)
}
catch {
    Write-Host 'Unable to determine previous NR Session process ID. Exiting.'
    Write-Host "$($_.Exception.Message)"
    Clear-NRSessionCustomFields
    exit 0
}

$MatchingNRPIDLog = $AllNRLogs | Where-Object { $_.Name -match $NRPIDConfirmation }

if (!($MatchingNRPIDLog)) {
    Write-Host 'Unable to match last NR session process ID. Exiting.'
    Clear-NRSessionCustomFields
    exit 0
}

$NRSessionEndTime = $($MatchingNRPIDLog.LastWriteTime).ToString("yyyy-MM-dd HH:mm:ss")

Ninja-Property-Set NinjaRemoteSessionEnd $NRSessionEndTime
Ninja-Property-Set NinjaRemoteSessionActive 0

if (!([string]::IsNullOrWhiteSpace($SetTag))) {
    Write-Host 'Removing NinjaTag'
    Remove-NinjaTag "$SetTag"
}

$NRPIDFiles | Remove-Item -Force

exit 0